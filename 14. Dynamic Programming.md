# 2d string dp

## Longest Common Subsequence
**easy**

Asked In:
ajio

Problem Description

Given two strings A and B. Find the longest common sequence ( A sequence which does not need to be contiguous), which is common in both the strings.

You need to return the length of such longest common subsequence.

```c++
int Solution::solve(string A, string B) {
    vector<vector<int>> dp(A.size()+1, vector<int>(B.size()+1,0));
    for(int i=1;i<=A.size();i++){
        for(int j=1;j<=B.size();j++){
            if(A[i-1]==B[j-1]){
                dp[i][j]=dp[i-1][j-1]+1;
            }
            else{
                dp[i][j]=max(dp[i-1][j], dp[i][j-1]);
            }
        }
    }
    return dp[A.size()][B.size()];
}

```

## Longest Palindromic Subsequence
**medium**

Asked In:
LinkedIn
BYJU'S

Problem Description
 
 

Given a string A, find the common palindromic sequence ( A sequence which does not need to be contiguous and is a pallindrome), which is common in itself.

You need to return the length of longest palindromic subsequence in A.

```c++
int Solution::solve(string A) {
    string B=A;
    reverse(begin(A),end(A));
    vector<vector<int>> dp(A.size()+1,vector<int>(A.size()+1,0));
    for(int i=1;i<=A.size();i++){
        for(int j=1;j<=A.size();j++){
            if(A[i-1]==B[j-1]){
                dp[i][j]=dp[i-1][j-1]+1;
            }
            else{
                dp[i][j]=max(dp[i-1][j], dp[i][j-1]);
            }
        }
    }
    return dp[A.size()][A.size()];
}

```

## Edit Distance
**medium**

Asked In:
Google
LinkedIn
Microsoft
more

Given two strings A and B, find the minimum number of steps required to convert A to B. (each operation is counted as 1 step.)

You have the following 3 operations permitted on a word:

    Insert a character
    Delete a character
    Replace a character


```c++
int Solution::minDistance(string A, string B) {
    int m=A.size(), n=B.size();
    vector<vector<int>> dp(m+1,vector<int>(n+1,0));
    for(int i=0;i<=m;i++){
        for(int j=0;j<=n;j++){
            if(i==0) dp[i][j]=j;
            if(j==0) dp[i][j]=i;
        }
    }
    for(int i=1;i<=m;i++){
        for(int j=1;j<=n;j++){
            if(A[i-1]==B[j-1]){
                dp[i][j]=dp[i-1][j-1];
            }
            else{
                dp[i][j]=1+min(dp[i-1][j], min(dp[i][j-1], dp[i-1][j-1]));
            }
        }
    }
    return dp[m][n];
}

```

## Repeating Sub-Sequence
**medium**

Asked In:
Google

Problem Description

Given a string A, find length of the longest repeating sub-sequence such that the two subsequence don’t have same string character at same position,

i.e., any i’th character in the two subsequences shouldn’t have the same index in the original string.

NOTE: Sub-sequence length should be greater than or equal to 2.

```c++
int Solution::anytwo(string A) {
    int m=A.size();
    vector<vector<int>> dp(m+1, vector<int>(m+1, 0));
    for(int i=1;i<=m;i++){
        for(int j=1;j<=m;j++){
            if(A[i-1]==A[j-1] && i!=j){
                dp[i][j]=dp[i-1][j-1]+1;
            }
            else{
                dp[i][j]=max(dp[i-1][j], dp[i][j-1]);
            }
        }
    }
    return dp[m][m]>=2?1:0;
}

```

# Knapsack

## 0-1 Knapsack
**medium**

Asked In:
Amazon
deshaw

Problem Description

Given two integer arrays A and B of size N each which represent values and weights associated with N items respectively.

Also given an integer C which represents knapsack capacity.

Find out the maximum value subset of A such that sum of the weights of this subset is smaller than or equal to C.

NOTE:

    You cannot break an item, either pick the complete item, or don’t pick it (0-1 property).


```c++
int Solution::solve(vector<int> &A, vector<int> &B, int C) {
    vector<vector<int>> dp(A.size()+1, vector<int>(C+1, -1));
    for(int i=0;i<=A.size();i++){
        for(int j=0;j<=C;j++){
            if(i==0||j==0){
                dp[i][j]=0;
            }
        }
    }
    for(int i=1;i<=A.size();i++){
        for(int j=1;j<=C;j++){
            if(B[i-1]<=j){
                dp[i][j]=max(A[i-1]+dp[i-1][j-B[i-1]], dp[i-1][j]);
            }
            else{
                dp[i][j]=dp[i-1][j];
            }
        }
    }
    return dp[A.size()][C];
}

```

## Flip Array
**medium**

Given an array of  positive elements, you have to flip the sign of some of its elements such that the resultant sum of the elements of array should be minimum non-negative(as close to zero as possible). Return the minimum no. of elements whose sign needs to be flipped such that the resultant sum is minimum non-negative.

> Extension of coin change problem 2 - init of dp by INT_MAX.

```c++
int Solution::solve(const vector<int> &A) {
    int sm=0;
    for(auto i:A) sm+=i;
    sm/=2;
    vector<vector<int>> dp(A.size()+1, vector<int>(sm+1,0));
    for(int i=0;i<=A.size();i++){
        for(int j=0;j<=sm;j++){
            if(i==0) dp[i][j]=INT_MAX;
            if(j==0) dp[i][j]=0;
        }
    }
    for(int i=1;i<=A.size();i++){
        for(int j=1;j<=sm;j++){
            if(A[i-1]<=j){
                dp[i][j]=min(1+(dp[i-1][j-A[i-1]]!=INT_MAX?dp[i-1][j-A[i-1]]:INT_MAX-1), dp[i-1][j]);
            }
            else{
                dp[i][j]=dp[i-1][j];
            }
        }
    }

    int ans=0;
    for(int j=sm;j>=0;j--){
        if(dp[A.size()][j]!=INT_MAX){ 
            ans=dp[A.size()][j];
            break;
        }
    }
    return ans;
}

```

## Equal Average Partition
**medium**

Asked In:
Amazon

Problem Description

Given an array A with non negative numbers, divide the array into two parts such that the average of both the parts is equal.

Return both parts (If exist). If there is no solution. return an empty list.

NOTE:
If a solution exists, you should return a list of exactly 2 lists of integers A and B which follow the following condition :
numElements in A <= numElements in B
If numElements in A = numElements in B, then A is lexicographically smaller than B ( https://en.wikipedia.org/wiki/Lexicographical_order )

If multiple solutions exist, return the solution where length(A) is minimum. If there is still a tie, return the one where A is lexicographically smallest.

Array will contain only non negative numbers.

```c++
typedef vector<int> vi;
typedef vector<bool> vb;
typedef vector<vector<bool>> vvb;
typedef vector<vector<vector<bool>>> vvvb;

bool dpfunc(vi &a1, vi &A, int idx, int cnt, int ssum, vvvb &dp){
    if(cnt==0){
        return ssum==0;
    }
    if(idx>=A.size()){
        return false;
    }
    if(dp[idx][ssum][cnt]==false){
        return false;
    }
    if(A[idx]<=ssum){
        a1.push_back(A[idx]);
        if(dpfunc(a1,A,idx+1,cnt-1,ssum-A[idx],dp)){
            return dp[idx][ssum][cnt]=true;
        }
        a1.pop_back();
    }
    if(dpfunc(a1,A,idx+1,cnt,ssum,dp)){
        return dp[idx][ssum][cnt]=true;
    }
    return dp[idx][ssum][cnt]=false;
}

vector<vector<int> > Solution::avgset(vector<int> &A) {
    sort(begin(A),end(A));
    int sm=0;
    for(auto i:A){
        sm+=i;
    }
    vi arr1;
    vvvb dp(A.size(), vvb(sm+1, vb(A.size(), true)));
    for(int i=1;i<=A.size()-1;i++){
        if((sm*i)%(A.size())==0){
            int ssum=sm*i/(A.size());
            vector<int> a1;
            if(dpfunc(a1,A,0,i,ssum,dp)){
                arr1=a1;
                break;
            }
        }
    }
    vector<vi> res;
    if(arr1.size()==0) return res;
    int x=0;
    vi arr2;
    for(int i=0;i<A.size();i++){
        if(x<arr1.size() && arr1[x]==A[i]){
            x++;
        }
        else{
            arr2.push_back(A[i]);
        }
    }
    return {arr1,arr2};
}

```

# Matrix dp

## Subset Sum Problem!
**medium**

Asked In:
Zenefits

Problem Description

Given an integer array A  of size N.

You are also given an integer B, you need to find whether their exist a subset in A whose sum equal B.

If there exist a subset then return 1 else return 0. 

```c++
int Solution::solve(vector<int> &A, int B) {
    vector<vector<bool>> dp(A.size()+1, vector<bool>(B+1,false));
    for(int i=0;i<A.size()+1;i++){
        for(int j=0;j<B+1;j++){
            if(j==0){
                dp[i][j]=true;
            }
        }
    }
    for(int i=1;i<A.size()+1;i++){
        for(int j=1;j<B+1;j++){
            if(A[i-1]<=j){
                dp[i][j]=dp[i-1][j-A[i-1]] || dp[i-1][j];
            }
            else{
                dp[i][j]=dp[i-1][j];
            }
        }
    }
    return dp[A.size()][B];
}
```

## Minimum Difference Subsets!
**medium**

Asked In:
tower research
uber

Problem Description

Given an integer array A containing N integers.

You need to divide the array A into two subsets S1 and S2 such that the absolute difference between their sums is minimum.

Find and return this minimum possible absolute difference.

NOTE:
Subsets can contain elements from A in any order (not necessary to be contiguous).
Each element of A should belong to any one subset S1 or S2, not both.
It may be possible that one subset remains empty.

```c++
int Solution::solve(vector<int> &A) {
    if(A.size()==1){
        return A[0];
    }
    int sm=0;
    for(auto i:A) sm+=i;
    vector<vector<bool>> dp(A.size()+1,vector<bool>(sm+1,false));
    for(int i=0;i<=A.size();i++){
        for(int j=0;j<=sm;j++){
            if(j==0) dp[i][j]=true;
        }
    }
    for(int i=1;i<=A.size();i++){
        for(int j=1;j<=sm;j++){
            if(A[i-1]<=j){
                dp[i][j]=dp[i-1][j] || dp[i-1][j-A[i-1]];
            }
            else{
                dp[i][j]=dp[i-1][j];
            }
        }
    }
    int ans=INT_MAX;
    for(int i=0;i<=sm/2;i++){
        if(dp[A.size()][i])
            ans=min(ans,sm-2*i);
    }
    return ans;
}

```