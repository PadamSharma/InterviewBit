# Subsets 

## Combination Sum
**medium**

Asked In:
Facebook
Amazon
Adobe

Problem Description
 
 

Given an array of candidate numbers A and a target number B, find all unique combinations in A where the candidate numbers sums to B.

The same repeated number may be chosen from A unlimited number of times.

Note:

1) All numbers (including target) will be positive integers.

2) Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).

3) The combinations themselves must be sorted in ascending order.

4) CombinationA > CombinationB iff (a1 > b1) OR (a1 = b1 AND a2 > b2) OR ... (a1 = b1 AND a2 = b2 AND ... ai = bi AND ai+1 > bi+1)

5) The solution set must not contain duplicate combinations.

```c++
void solve(vector<int> A, int target, vector<vector<int>> &ans, vector<int> &temp, int i, int sum){
    if(sum>target) return;
    if(i>=A.size()){
        if(target==sum){
            ans.push_back(temp);
        }
        return;
    }
    temp.push_back(A[i]);
    solve(A, target, ans, temp, i, sum+A[i]);
    temp.pop_back();
    solve(A, target, ans, temp, i+1, sum);
}

vector<vector<int> > Solution::combinationSum(vector<int> &A, int B) {
    vector<vector<int>> ans;
    vector<int> temp;
    vector<int> nodupes;
    set<int> s(begin(A), end(A));
    int j=0;
    for(auto i:s){
        nodupes.push_back(i);
    }
    solve(nodupes, B, ans, temp, 0, 0);
    return ans;
}

```

## Combination Sum II
**medium**

Asked In:
Microsoft
Amazon
Infosys

Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.

Each number in C may only be used once in the combination.

    Note:

        All numbers (including target) will be positive integers.
        Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).
        The solution set must not contain duplicate combinations.



```c++
typedef vector<vector<int>> vvi;
typedef vector<int> vi;
void solve(vi &temp, int idx, vvi &ans, vi A, int target){
    if(target==0){
        ans.push_back(temp);
        return;
    }
    for(int i=idx;i<A.size();i++){
        if(i>idx && A[i]==A[i-1]){
            continue;
        }
        if(A[i]>target){
            break;
        }
        temp.push_back(A[i]);
        solve(temp, i+1, ans, A, target-A[i]);
        temp.pop_back();
    }
}

vector<vector<int> > Solution::combinationSum(vector<int> &A, int B) {
    vvi ans;
    vi temp;
    sort(begin(A), end(A));
    solve(temp, 0, ans, A, B);
    return ans;    
}
```

## Subset
**medium**

Asked In:
Amazon
Microsoft

Given a set of distinct integers, S, return all possible subsets.

    Note:

        Elements in a subset must be in non-descending order.
        The solution set must not contain duplicate subsets.
        Also, the subsets should be sorted in ascending ( lexicographic ) order.
        The list is not necessarily sorted.



```c++
typedef vector<vector<int>> vvi;
typedef vector<int> vi;
void solve(vi A, int idx, vvi &ans, vi &temp){
    if(idx>=A.size()){
        ans.push_back(temp);
        return;
    }
    temp.push_back(A[idx]);
    solve(A, idx+1, ans, temp);
    temp.pop_back();
    solve(A, idx+1, ans, temp);
}
vector<vector<int> > Solution::subsets(vector<int> &A) {
    vvi ans;
    vi temp;
    sort(begin(A), end(A));
    solve(A, 0, ans, temp);
    sort(begin(ans), end(ans));
    return ans;
}
```