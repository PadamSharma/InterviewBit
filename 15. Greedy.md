# Easy Greedy

## Highest Product
**easy**

Asked In:
Coursera
Amazon

Given an array A, of N integers A.

Return the highest product possible by multiplying 3 numbers from the array.

NOTE:  Solution will fit in a 32-bit signed integer.

```c++
int Solution::maxp3(vector<int> &A) {
    sort(begin(A), end(A));
    if(A.size()==1){
        return A[0];
    }
    else if(A.size()==2){
        return A[0]*A[1];
    }
    else if(A.size()==3){
        return A[0]*A[1]*A[2];
    }
    int beg = A[0]*A[1]*A[A.size()-1];
    int end = A[A.size()-1]*A[A.size()-2]*A[A.size()-3];
    return max(beg,end);
}

```

## Bulbs
**easy**

Problem Description
 
 
N light bulbs are connected by a wire.

Each bulb has a switch associated with it, however due to faulty wiring, a switch also changes the state of all the bulbs to the right of current bulb.

Given an initial state of all bulbs, find the minimum number of switches you have to press to turn on all the bulbs.

You can press the same switch multiple times.

Note : 0 represents the bulb is off and 1 represents the bulb is on.

```c++
int Solution::bulbs(vector<int> &A) {
    int rev = 0;
    int ans = 0;
    for(int i=0;i<A.size();i++){
        if(A[i] == 0 && rev == 0){
            rev=rev?0:1;
            ans++;
        }
        else if(A[i] == 1 && rev == 1){
            rev=rev?0:1;
            ans++;
        }
    }
    return ans;
}


```

## Disjoint Intervals
**medium**

Asked In:
Google

Problem Description

Given a set of N intervals denoted by 2D array A of size N x 2, the task is to find the length of maximal set of mutually disjoint intervals.

Two intervals [x, y] & [p, q] are said to be disjoint if they do not have any point in common.

Return a integer denoting the length of maximal set of mutually disjoint intervals.

```c++
bool sortbysec(const vector<int> &a,
              const vector<int> &b)
{
    return (a[1] < b[1]);
}
int Solution::solve(vector<vector<int> > &A) {
    sort(A.begin(), A.end(), sortbysec);
    int ans=1;
    int lstele=A[0][1];
    for(int i=1;i<A.size();i++){
        // cout<<A[i][0]<<' '<<A[i][1] <<" : "<< A[i+1][0]<<' '<<A[i+1][1]<<endl;
        if(lstele < A[i][0]){
            ans++;
            lstele=A[i][1];
        }
    }
    return ans;
}

```

# Medium greedy

## Majority Element
**easy**

Asked In:
Microsoft
Yahoo
Google
more

Problem Description
Given an array of size n, find the majority element. The majority element is the element that appears more than floor(n/2) times.

You may assume that the array is non-empty and the majority element always exist in the array.

```c++
int Solution::majorityElement(const vector<int> &A) {
    // unordered_map<int,int> mp;
    // for(auto i:A){
    //     mp[i]++;
    // }
    // for(auto i:mp){
    //     if(i.second>A.size()/2){
    //         return i.first;
    //     }
    // }
    // return 0;
    int mjrtyidx = 0;
    int cnt=1;
    for(int i=1;i<A.size();i++){
        A[mjrtyidx]==A[i]?cnt++:cnt--;
        if(cnt==0){
            mjrtyidx=i;
            cnt=1;
        }
    }
    return A[mjrtyidx];
}
```

## Assign Mice to Holes
**easy**

Asked In:
Amazon

Problem Description

There are N Mice and N holes that are placed in a straight line. Each hole can accomodate only 1 mouse.

The positions of Mice are denoted by array A and the position of holes are denoted by array B.

A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x âˆ’ 1. Any of these moves consumes 1 minute.

Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.

```c++
int Solution::mice(vector<int> &A, vector<int> &B) {
    sort(begin(A), end(A));
    sort(begin(B), end(B));
    for(int i=0;i<A.size();i++){
        A[i]=abs(A[i]-B[i]);
    }
    return *max_element(begin(A), end(A));
}

```

## 


```c++

```